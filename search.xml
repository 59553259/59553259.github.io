<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue组件之间的传值]]></title>
    <url>%2F2018%2F08%2F26%2FcomponentsValue%2F</url>
    <content type="text"><![CDATA[组件（component）是Vue最强大的功能之一，项目中经常会遇到组件之间的传值问题。下面对自定义Vue组件，以及组件之间的传值问题进行总结。 自定义Vue组件123456789// 定义一个名为 button-counter 的新组件Vue.component('button-counter', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：1234567//HTML:&lt;div id="components-demo"&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;//JS:new Vue(&#123; el: '#components-demo' &#125;) 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项 父组件往子组件传值通过 Prop 向子组件传递数据:Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。为了给博文组件传递一个标题，我们可以用一个 props 选项将其包含在该组件可接受的 prop 列表中：1234Vue.component('blog-post', &#123; props: ['title'], template: '&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'&#125;) 在HTML便可使用blog-post调用这个组件，并通过title将数值传给父组件：123&lt;blog-post title="My journey with Vue"&gt;&lt;/blog-post&gt;&lt;blog-post title="Blogging with Vue"&gt;&lt;/blog-post&gt;&lt;blog-post title="Why Vue is so fun"&gt;&lt;/blog-post&gt; 然而在一个典型的应用中，你可能在 data 里有一个博文的数组：12345678910new Vue(&#123; el: '#blog-post-demo', data: &#123; posts: [ &#123; id: 1, title: 'My journey with Vue' &#125;, &#123; id: 2, title: 'Blogging with Vue' &#125;, &#123; id: 3, title: 'Why Vue is so fun' &#125; ] &#125;&#125;) 在HTML中，可以使用 v-bind 来动态传递 prop：12345&lt;blog-post v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title"&gt;&lt;/blog-post&gt; 通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些属性的名称和值分别是 prop 各自的名称和类型：1234567props: &#123; title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object&#125; 传递的参数名称不识别驼峰命名，推荐使用短横线命名法(横杠-命名) 子组件往父组件传值通过emit事件子组件往父组件传值:下例子组件通过$emit(&#39;child-say&#39;,this.data)触发父组件的child-say事件，从而向父组件传值。父组件:1234567&lt;component @child-say="listenToMyBoy"&gt;&lt;/component&gt;&lt;p&gt;&#123;&#123;childWords&#125;&#125;&lt;/p&gt; methods: &#123; listenToMyBoy: function (data)&#123; this.childWords = data &#125; &#125; 子组件：123456&lt;button @click="onClickMe"&gt;点击传值&lt;/button&gt;methods: &#123; onClickMe: function()&#123; this.$emit('child-say','所传的值'); &#125; &#125; 不同组件之间传值使用vuex进行传值]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中this关键字的用法]]></title>
    <url>%2F2018%2F08%2F21%2Fthis%2F</url>
    <content type="text"><![CDATA[前言this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。一般来说，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。 this的四种绑定机制 默认绑定规则：在非严格模式下，默认绑定的this指向全局对象，严格模式下this指向undefined 12345678910function foo() &#123; console.log(this.a); // this指向全局对象&#125;var a = 2;foo(); // 2function foo2() &#123; "use strict"; // 严格模式this绑定到undefined console.log(this.a); &#125;foo2(); // TypeError:a undefined 隐式绑定规则：函数在调用位置，是否有上下文对象，如果有，那么this就会隐式绑定到这个对象上。 123456789101112131415161718function foo() &#123; console.log(this.a);&#125;var a = "Oops, global";let obj2 = &#123; a: 2, foo: foo&#125;;let obj1 = &#123; a: 22, obj2: obj2&#125;;obj2.foo(); // 2 this指向调用函数的对象obj1.obj2.foo(); // 2 this指向最后一层调用函数的对象// 隐式绑定丢失let bar = obj2.foo; // bar只是一个函数别名 是obj2.foo的一个引用bar(); // "Oops, global" - 指向全局 隐式绑定丢失:函数调用时，并没有上下文对象，只是对函数的引用，所以会导致隐式绑定丢失。 显式绑定规则：在某个对象上强制调用函数，通过apply、call、bind将函数中的this绑定到指定对象上,从而将this绑定在这个函数上。 1234567function foo() &#123; console.log(this.a);&#125;let obj = &#123; a: 2&#125;;foo.call(obj); // 2 new绑定(构造函数模式)规则：使用构造调用的时候，this会自动绑定在new期间创建的对象上。 12345function foo(a) &#123; this.a = a; // this绑定到bar上&#125;let bar = new foo(2);console.log(bar.a); // 2 箭头函数的this指向问题箭头函数的this指向不会使用上述的四条规则。规则： 箭头函数中的this继承于它外面第一个不是箭头函数的函数的this指向。 箭头函数的 this 一旦绑定了上下文，就不会被任何代码改变。12345678910111213function foo() &#123; return () =&gt; &#123; console.log(this.a); &#125;;&#125;let obj1 = &#123; a: 2&#125;;let obj2 = &#123; a: 22&#125;;let bar = foo.call(obj1); // foo this指向obj1bar.call(obj2); // 输出2 这里执行箭头函数 并试图绑定this指向到obj2]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router导航守卫]]></title>
    <url>%2F2018%2F08%2F18%2FvueRouter%2F</url>
    <content type="text"><![CDATA[导航守卫vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航,比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。对此有多种方法植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。记住参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。 全局守卫vue-router全局有三个守卫： router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后使用方法：12345678910import router from './router'; // 引入路由router.beforeEach((to, from, next) =&gt; &#123; next();&#125;);router.beforeResolve((to, from, next) =&gt; &#123; next();&#125;);router.afterEach((to, from) =&gt; &#123; console.log('afterEach 全局后置钩子');&#125;); 守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于等待中。 每个守卫方法接收三个参数： to 即将要进入的目标 路由对象 from 当前导航正要离开的路由 next() 这个参数是个函数，且必须调用，否则钩子就不会被 resolved,不能进入路由(页面空白) next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 路由独享守卫你可以在路由配置上直接定义 beforeEnter 守卫：1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 这些守卫与全局守卫的方法参数是一样的,其调用顺序在全局前置守卫后面，不会被全局守卫所覆盖 组件内的守卫你可以在路由组件内直接定义以下路由导航守卫： beforeRouteEnter 进入路由前 beforeRouteUpdate (2.2 新增)路由复用同一个组件时 beforeRouteLeave 离开当前路由时123456789101112131415161718const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。12345beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; // 通过 `vm` 访问组件实例 &#125;)&#125; beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。1234beforeRouteUpdate (to, from, next) &#123; this.name = to.params.name next()&#125; 这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。12345678beforeRouteLeave (to, from , next) &#123; const answer = window.confirm('Do you really want to leave? you have unsaved changes!') if (answer) &#123; next() &#125; else &#123; next(false) &#125;&#125; 跳转死循环，页面永远空白问题例如：1234567router.beforeEach((to, from, next) =&gt; &#123; if(登录)&#123; next() &#125;else&#123; next(&#123; name: 'login' &#125;); &#125;&#125;); 当未登录转到login之后，因为此时的状态仍然还是未登录，所以会一直跳转到login然后死循环，故页面一直显示为空白。解决：1234567router.beforeEach((to, from, next) =&gt; &#123; if(登录 || to.name === 'login')&#123; // 登录，或者将要前往login页面的时候，就允许进入路由 next() &#125;else&#123; next(&#123; name: 'login' &#125;); &#125;&#125;); 完整的导航解析流程 导航被触发。 在失活的组件里调用离开守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫 (2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less入门]]></title>
    <url>%2F2018%2F08%2F12%2Fless%2F</url>
    <content type="text"><![CDATA[前言CSS作为一门标记性语言，虽然简单易懂，但毫无逻辑性可言，遭到一些程序员的不喜。随着技术的兴起，为了使CSS富有逻辑性，涌现出了例如Sass、Less之类的预处理语言。它们让CSS彻底变成一门可以使用变量、循环、继承、自定义方法等多种特性的标记语言，逻辑性得以大大增强。Less诞生于2009年，它扩充了CSS语言，增加了诸如变量、混合、函数等功能，让CSS更易维护、方便制作主题、扩充。它没有去掉任何CSS的功能，而是在现有的语法上，增添了许多额外的功能特性。附上Less的官网：Less 如何使用Less 本地环境在页面中 引入 Less.js 12&lt;link rel="stylesheet/less" href="style.less"&gt;&lt;script src="less.min.js"&gt;&lt;/script&gt; 注意：link 标签一定要在 Less.js 之前引入，并且 link 标签的 rel 属性要设置为stylesheet/less。less.min.js可以去官网下载，也可以使用CDN&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/2.7.2/less.min.js&quot;&gt;&lt;/script&gt; 生产环境在命令行,使用npm安装 12npm install -g less$ lessc styles.less &gt; styles.css 如果使用Webpack，需配合 less-loader 进行处理 变量 值变量 1234567891011121314/* Less */ @color: #999; @bgColor: skyblue;//不要添加引号 @width: 50%; #wrap &#123; color: @color; width: @width; &#125; /* 生成后的 CSS */ #wrap &#123; color: #999; width: 50%; &#125; 以 @ 开头定义变量，并且使用时直接键入 @名称。 在平时工作中，我们就可以把常用的变量封装到一个文件中，这样利于代码组织维护。1234567@lightPrimaryColor: #c5cae9; @textPrimaryColor: #fff; @accentColor: rgb(99, 137, 185); @primaryTextColor: #646464; @secondaryTextColor: #000; @dividerColor: #b6b6b6; @borderColor: #dadada; 变量是常量，只能定义一次，不能重复使用。 选择器变量 12345678910111213141516171819202122232425/* Less */ @mySelector: #wrap; @Wrap: wrap; @&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹 color: #999; width: 50%; &#125; .@&#123;Wrap&#125;&#123; color:#ccc; &#125; #@&#123;Wrap&#125;&#123; color:#666; &#125; /* 生成的 CSS */ #wrap&#123; color: #999; width: 50%; &#125; .wrap&#123; color:#ccc; &#125; #wrap&#123; color:#666; &#125; 属性变量 1234567891011/* Less */ @borderStyle: border-style; @Soild:solid; #wrap&#123; @&#123;borderStyle&#125;: @Soild;//变量名 必须使用大括号包裹 &#125; /* 生成的 CSS */ #wrap&#123; border-style:solid; &#125; url变量 12345678910/* Less */ @images: "../img";//需要加引号 body &#123; background: url("@&#123;images&#125;/dog.png");//变量名 必须使用大括号包裹 &#125; /* 生成的 CSS */ body &#123; background: url("../img/dog.png"); &#125; 项目结构改变时，修改其变量即可。 声明变量 12345678910111213141516171819202122232425- 结构: @name: &#123; 属性: 值 ;&#125;;- 使用：@name(); /* Less */ @background: &#123;background:red;&#125;; #main&#123; @background(); &#125; @Rules:&#123; width: 200px; height: 200px; border: solid 1px red; &#125;; #con&#123; @Rules(); &#125; /* 生成的 CSS */ #main&#123; background:red; &#125; #con&#123; width: 200px; height: 200px; border: solid 1px red; &#125; 变量运算 123456789101112131415161718192021- 加减法时 以第一个数据的单位为基准- 乘除法时 注意单位一定要统一 /* Less */ @width:300px; @color:#222; #wrap&#123; width:@width-20; height:@width-20*5; margin:(@width-20)*5; color:@color*2; background-color:@color + #111; &#125; /* 生成的 CSS */ #wrap&#123; width:280px; height:200px; margin:1400px; color:#444; background-color:#333; &#125; 变量作用域 123456789101112/* Less */ @var: @a; @a: 100%; #wrap &#123; width: @var; @a: 9%; &#125; /* 生成的 CSS */ #wrap &#123; width: 9%; &#125; 就近原则 用变量去定义变量12345678910/* Less */ @fnord: "I am fnord."; @var: "fnord"; #wrap::after&#123; content: @@var; //将@var替换为其值 content:@fnord; &#125; /* 生成的 CSS */ #wrap::after&#123; content: "I am fnord."; &#125; 嵌套 &amp; 的用法&amp;：代表的上一层选择器的名字，此例便是header 12345678910111213141516/* Less */ #header&#123; &amp;:after&#123; content:"Less is more!"; &#125; &amp;_content&#123;//理解方式：直接把 &amp; 替换成 #header margin:20px; &#125; &#125; /* 生成的 CSS */ #header::after&#123; content:"Less is more!"; &#125; #header_content&#123; margin:20px; &#125; 媒体查询 123456789101112131415161718192021222324/* Less */ #main&#123; //something... @media screen&#123; @media (max-width:768px)&#123; width:100px; &#125; &#125; @media tv &#123; width:2000px; &#125; &#125; /* 生成的 CSS */ @media screen and (maxwidth:768px)&#123; #main&#123; width:100px; &#125; &#125; @media tv&#123; #main&#123; width:2000px; &#125; &#125; 混合方法 无参数方法方法犹如声明的集合，使用时直接键入名称即可。 123456789101112131415161718192021222324252627282930/* Less */ .card() &#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; #wrap&#123; .card(); &#125; /* 生成的 CSS */ #wrap&#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; /* Less */ .card() &#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; #wrap&#123; .card(); &#125; /* 生成的 CSS */ #wrap&#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; 默认参数方法Less 可以使用默认参数，如果没有传参数，那么将使用默认参数。@arguments 犹如 JS 中的 arguments 指代的是全部参数。传的参数中必须带着单位。 1234567891011121314151617181920212223#main&#123; .border(0px,5px,30px,red);//必须带着单位 &#125; #wrap&#123; .border(0px); &#125; #content&#123; .border;//等价于 .border() &#125; /* 生成的 CSS */ #main&#123; border:solid 1px red; box-shadow:0px,5px,30px,red; &#125; #wrap&#123; border:solid 1px #000; box-shadow: 0px 50px 30px #000; &#125; #content&#123; border:solid 1px #000; box-shadow: 10px 50px 30px #000; &#125; 方法的匹配模式 123456789101112131415161718192021222324252627/* Less */ .triangle(top,@width:20px,@color:#000)&#123; border-color:transparent transparent @color transparent ; &#125; .triangle(right,@width:20px,@color:#000)&#123; border-color:transparent @color transparent transparent ; &#125; .triangle(bottom,@width:20px,@color:#000)&#123; border-color:@color transparent transparent transparent ; &#125; .triangle(left,@width:20px,@color:#000)&#123; border-color:transparent transparent transparent @color; &#125; .triangle(@_,@width:20px,@color:#000)&#123; border-style: solid; border-width: @width; &#125; #main&#123; .triangle(left, 50px, #999) &#125; /* 生成的 CSS */ #main&#123; border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px; &#125; 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量，则将会匹配，如 @_ 。 方法的命名空间123456789101112131415161718192021222324252627282930313233343536/* Less */ #card()&#123; background: #723232; .d(@w:300px)&#123; width: @w; #a(@h:300px)&#123; height: @h;//可以使用上一层传进来的方法 width: @w; &#125; &#125; &#125; #wrap&#123; #card &gt; .d &gt; #a(100px); // 父元素不能加 括号 &#125; #main&#123; #card .d(); &#125; #con&#123; //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card &#125; /* 生成的 CSS */ #wrap&#123; height:100px; width:300px; &#125; #main&#123; width:300px; &#125; #con&#123; width:20px; &#125; 在 CSS 中&gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 方法的条件筛选Less 没有 if else，可是它有 when1234567891011121314151617181920212223242526272829/* Less */ #card&#123; // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行 .border(@width,@color,@style) when (@width&gt;100px) and(@color=#999)&#123; border:@style @color @width; &#125; // not 运算符，相当于 非运算 !，条件为 不符合才会执行 .background(@color) when not (@color&gt;=#222)&#123; background:@color; &#125; // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行 .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px)&#123; font-size: @size; &#125; &#125; #main&#123; #card&gt;.border(200px,#999,solid); #card .background(#111); #card &gt; .font(40px); &#125; /* 生成后的 CSS */ #main&#123; border:solid #999 200px; background:#111; font-size:40px; &#125; 比较运算有： &gt; &gt;= = =&lt; &lt;。 = 代表的是等于 除去关键字 true 以外的值都被视为 false 数量不定的参数如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符 1234567891011121314151617/* Less */ .boxShadow(...)&#123; box-shadow: @arguments; &#125; .textShadow(@a,...)&#123; text-shadow: @arguments; &#125; #main&#123; .boxShadow(1px,4px,30px,red); .textShadow(1px,4px,30px,red); &#125; /* 生成后的 CSS */ #main&#123; box-shadow: 1px 4px 30px red; text-shadow: 1px 4px 30px red; &#125; 循环方法Less 并没有提供 for 循环功能，但这也难不倒 聪明的程序员，使用递归去实现。 12345678910111213141516171819202122/* Less */ .generate-columns(4); .generate-columns(@n, @i: 1) when (@i =&lt; @n) &#123; .column-@&#123;i&#125; &#123; width: (@i * 100% / @n); &#125; .generate-columns(@n, (@i + 1)); &#125; /* 生成后的 CSS */ .column-1 &#123; width: 25%; &#125; .column-2 &#123; width: 50%; &#125; .column-3 &#123; width: 75%; &#125; .column-4 &#123; width: 100%; &#125; 属性拼接方法 +代表的是空格 123456789101112/* Less */ .boxShadow() &#123; box-shadow+: inset 0 0 10px #555; &#125; .main &#123; .boxShadow(); box-shadow+: 0 0 20px black; &#125; /* 生成后的 CSS */ .main &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black; &#125; +_代表的是逗号。 12345678910111213/* Less */ .Animation() &#123; transform+_: scale(2); &#125; .main &#123; .Animation(); transform+_: rotate(15deg); &#125; /* 生成的 CSS */ .main &#123; transform: scale(2) rotate(15deg); &#125; 继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。 extend 关键字的使用 123456789101112131415161718192021/* Less */ .animation&#123; transition: all .3s ease-out; .hide&#123; transform:scale(0); &#125; &#125; #main&#123; &amp;:extend(.animation); &#125; #con&#123; &amp;:extend(.animation .hide); &#125; /* 生成后的 CSS */ .animation,#main&#123; transition: all .3s ease-out; &#125; .animation .hide , #con&#123; transform:scale(0); &#125; all 全局搜索替换 123456789101112131415161718/* Less */ #main&#123; width: 200px; &#125; #main &#123; &amp;:after &#123; content:"Less is good!"; &#125; &#125; #wrap:extend(#main all) &#123;&#125; /* 生成的 CSS */ #main,#wrap&#123; width: 200px; &#125; #main:after, #wrap:after &#123; content: "Less is good!"; &#125; 选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre). 可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr);等同于pre:hover:extend(div pre, .bucket tr) 这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。 如果一个规则集包含多个选择器，所有选择器都可以使用extend关键字。 导入 referenceLess 中最强大的特性使用引入的 Less 文件，但不会编译它。1234/* Less */@import (reference) "bootstrap.less"; #wrap:extend(.navbar all)&#123;&#125; 使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用 once12@import (once) "foo.less";@import (once) "foo.less"; // this statement will be ignored @import语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。 multiple1234567891011121314151617/* Less */ // file: foo.less.a &#123; color: green;&#125;// file: main.less@import (multiple) "foo.less";@import (multiple) "foo.less"; /* 生成后的 CSS */.a &#123; color: green;&#125;.a &#123; color: green;&#125; 使用@import (multiple)允许导入多个同名文件。 函数 判断类型 isnumber（判断给定的值是否是一个数字） iscolor（判断给定的值是否是一个颜色） isurl（判断给定的值是否是一个 url） 颜色操作 saturate（增加一定数值的颜色饱和度） lighten（增加一定数值的颜色亮度） darken（降低一定数值的颜色亮度） fade（给颜色设定一定数值的透明度） mix（根据比例混合两种颜色） 数学函数 ceil（向上取整） floor（向下取整） percentage（将浮点数转换为百分比字符串） round（四舍五入） sqrt（计算一个数的平方根） abs（计算数字的绝对值，原样保持单位） pow（计算一个数的乘方） Less中使用JS因为 Less 是由 JS 编写，所以 Less 有一得天独厚的特性：代码中使用JS1234567891011121314151617181920212223242526/* Less */ @content:`"aaa".toUpperCase()`; #randomColor&#123; @randomColor: ~"rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)"; &#125; #wrap&#123; width: ~"`Math.round(Math.random() * 100)`px"; &amp;:after&#123; content:@content; &#125; height: ~"`window.innerHeight`px"; alert:~"`alert(1)`"; #randomColor(); background-color: @randomColor; &#125; /* 生成后的 CSS */ // 弹出 1 #wrap&#123; width: 随机值（0~100）px; height: 743px;//由电脑而异 background: 随机颜色; &#125; #wrap::after&#123; content:"AAA"; &#125; 参考：学习Less-看这篇就够了]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期详解]]></title>
    <url>%2F2018%2F08%2F04%2FnewVue%2F</url>
    <content type="text"><![CDATA[每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等，这个过程就是vue的生命周期。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 Vue的生命周期图示上图是Vue官方文档上的生命周期图示。由图可以看到在vue一整个的生命周期中会有以下八个钩子函数提供给我们在vue生命周期不同的时刻进行操作： beforeCreate（此时date、method和el均没有初始化，可以在此加载loading） created（此时date和method初始化完成，但是DOM节点并没有挂载，判断是否有el节点，如果有则编译template，如果没有则使用vm.$mount创建一个默认节点，此时可以在DOM渲染之前进行数据的初始化和method的自执行等）template参数选项的有无对生命周期的影响。①.如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。②.如果没有template选项，则将外部HTML作为模板编译。③.可以看到template中的模板优先级要高于outer HTML的优先级。 render函数选项 &gt; template选项 &gt; outer HTML. beforeMount（编译模板，并且将此时在el上挂载一个虚拟的DOM节点） mounted（编译模板，且将真实的DOM节点挂载在el上） beforeUpdate（在数据有更新时，进入此钩子函数，虚拟DOM被重新创建） updated（数据更新完成时，进入此钩子函数） beforeDestory（组件销毁前调用，此时将组件上的watchers、子组件和事件都移除掉） destoryed（组件销毁后调用） 一般一个Vue实例初始化时，只会执行前四个钩子函数 Vue实例和子组件之间的生命周期在Vue中，由于父元素的template模板嵌套了子元素，因此在编译模板时，会先进入到父元素的template，然后层层递归进行子元素的模板编译。在创建时，父子组件的生命周期是：父组件beforeCreated -&gt; 父组件created -&gt; 父组件beforeMounted -&gt; 子组件beforeCreated -&gt; 子组件created -&gt; 子组件beforeMounted -&gt; 子组件mounted -&gt; 父组件mounted。在销毁时，父子组件的生命周期是：父组件beforeDestory -&gt; 子组件beforeDestoryed -&gt; 子组件destoryed -&gt; 父组件destoryed 父子组件的生命周期遵循：由外到内，再由内到外 几个常见操作 ajax请求 ajax请求最好放在created里面，因为此时已经可以访问this了，请求到数据就可以直接放在data里面。 dom操作 关于dom的操作要放在mounted里面，在mounted前面访问dom会是undefined。 进入组件时操作可以用created和mounted钩子 离开的时候用beforeDestory和destroyed钩子(beforeDestory可以访问this，destroyed不可以访问this)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入域名到页面展示的全过程]]></title>
    <url>%2F2018%2F07%2F29%2FpageShow%2F</url>
    <content type="text"><![CDATA[从浏览器输入域名，到页面展示的过程大致可简单概括为以下几个部分：1.解析输入的域名，获得该域名的IP地址2.向服务器发送请求3.服务器收到、处理、返回请求4.浏览器渲染页面 域名解析DNS查找域名的IP地址会先在缓存中进行查询，其先后顺序为： 1.浏览器缓存 ：在浏览器的缓存中查找是否有该域名对应的IP地址，若有则直接返回IP地址，若无则进行下一步 2.系统缓存 ：系统缓存指本地硬盘上的hosts文件，该文件一般位于系统的C:\Windows\System32\drivers\etc\hosts 3.路由器缓存 : 查找路由器缓存中是否有对应的IP地址 如果在浏览器缓存、系统缓存、路由器缓存中都没有找到ip地址，浏览器便会发起一个DNS请求到本地DNS服务器本地DNS服务器一般是由你的网络接入的服务商提供，如：电信、联通、移动 4.本地DNS服务器 ：DNS请求到达本地DNS服务器后，本地DNS服务器会先在自己的缓存中查找如果找到了就返回找到的IP,这个过程是以递归的方式进行的如果没有，则本地DNS服务器继续向根域名服务器发起请求 5.根域名服务器：本地DNS继续向根域名服务器发出查询请求根域名服务器并没有记录域名与IP之间的对应关系根域名服务器告诉本地DNS服务器，可以到哪个顶级域名服务器上查询 6.顶级域名服务器：本地DNS继续向顶级域名服务器发出查询请求顶级域名服务器接收到请求后，会告诉本地DNS到权限域名服务器上去查询 7.权限域名服务器 ：本地DNS继续向权限域名服务器发出查询请求权限域名服务器查询到域名对应的IP后，将IP地址返回给本地DNS 本地DNS接收后将其保存到自己的缓存中，以备下次查询，提高查询速度至此，一个IP地址的查询就此结束； 整个DNS域名解析是一个递归查询的过程本地域名服务器向根域名服务器、顶级域名服务器和主机域名服务器发起的查询请求是一个迭代查询的过程 发送请求浏览器拿到域名对应的IP地址之后，会向服务器发起TCP连接请求连接请求到达服务器端后，通过三次握手建立TCP连接建立TCP连接后，浏览器向服务器发送http请求 浏览器发送请求的端口为1024~65535的一个随机端口向服务器的请求端口为：HTTP协议使用80端口/8080端口，HTTPS使用443端口 响应请求服务器收到客户端请求后，对请求进行处理，包括访问数据库、获取需要获取的内容等然后服务器向浏览器返回一个HTTP响应，将请求的数据发送给浏览器浏览器收到请求后通过四次挥手释放TCP连接 渲染页面页面渲染主要分为以下几步： 1.浏览器把获取到的HTML代码解析成1个DOM树 HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等 2.浏览器把CSS解析成CSSOM(样式结构体)，在解析的过程中会去掉浏览器不能识别的样式 3.DOM Tree 和CSSOM组合后构建render tree render tree类似于DOM tree，但区别很大，render tree能识别样式，render tree中每个node都有自己的stylerender tree不包含隐藏的节点 (这些节点不会用于呈现，而且不会影响呈现的,比如display:none的节点)visibility:hidden隐藏的元素还是会包含到 render tree中的(visibility:hidden 会影响布局(layout)，会占有空间) 4.浏览器根据render tree渲染和展示页面 浏览器在构造页面时，当浏览器从服务器端接收到HTML文档时，会从上到下依次解析HTML文档，转换为DOM树在转换过程中，如果发现某个Node（节点）引用了CSS、IMG，则会发起一个request去请求CSS或IMG,而浏览器则会继续执行下面的HTML转换，而不等待request的返回,当request返回后，只需要把相应的内容放到对应的Node上即可但是当引用了JS的时候，浏览器发起一个JS的request请求后，会一直等待该请求的返回,因为浏览器需要构建一个稳定的DOM树，而JS代码很有可能会改变DOM结构,浏览器为了防止出现这种情况，所以会阻塞后续资源的下载 回流与重绘回流：当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建 每个页面至少需要一次回流，就是在页面第一次加载的时候 重绘:当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局 回流必将引起重绘，而重绘不一定会引起回流在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树,完成回流后，浏览器会重新绘制受影响的部分到屏幕中回流可以理解为render树的结构发生了变化，需要重新构建重绘指结构没有变化，只是一些对结构布局没有产生影响的元素发生了变化]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2018%2F07%2F21%2FMarkdown%2F</url>
    <content type="text"><![CDATA[前言在使用Hexo搭建博客系统后，通过hexo new XXX创建一个新的博客文章，编写博客内容所使用的模板为.md文件对此，有必要了解一下关于Markdown的基本语法，以提高写作效率。 Markdown介绍Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。优点： 纯文本格式，故可以用任何编辑器打开并编辑 语法简介易懂，具有很好的可读性 转化格式方便，可以轻松转化为Html、PPT、Word等格式文件 基本语法介绍标题在 Markdown 中，只需在文本前面加上#即可表示标题，标题总共六级同理，二级标题、三级标题、四级标题、五级标题和六级标题都只需要添加相应数量的#即可，标题字号便会相应降低。例如：123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 注：#和标题之间建议保留一个字符的空格。 字体 加粗 :将要加粗的文字用两个*号包起来 **Bold** —– Bold 斜体 :将要倾斜的文字用一个*号包起来 斜体加粗 :将要倾斜加粗的文字用三个*号包起来 删除线 : 将要加删除线的文字用两个~~号包起来 引用 引用 :在引用的文字前加&gt;即可例如： &gt; 引用内容 引用内容 分割线 分割线 (HR) :三个或者三个以上的-或者*例如 : --- *** 链接 链接 :[超链接名](超链接地址)例如 :[百度](https://www.baidu.com/)显示为 :百度 图片12345![alt](address "title")alt是指显示在图片下面的文字 address是指图片的地址title是指当鼠标移到图片上时显示的内容，title可有可无 例如 :![头像](source/uploads/touxiang.jpg) 列表无序列表语法：无序列表用- + *任何一种都可以例如 :12- 有序列表- 无序列表 显示为 : 有序列表 无序列表有序列表语法：数字加点例如 : 121.有序列表 2.无序列表 显示为：1.有序列表2.无序列表 列表嵌套在下一级的-符号前敲四个空格例如 :1234- 一级列表 - 二级列表 - 二级列表 - 二级列表 显示为： 一级列表 二级列表 二级列表 二级列表 表格语法为 :1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 第二行分割表头和内容文字默认居左--- 表示文字居左：--：表示文字居中----：表示文字居右显示为： 表头 表头 表头 内容 内容 内容 内容 内容 内容 内嵌代码单行代码：将代码用一个反引号包起来alert(&#39;Hello World&#39;); 多行代码：将代码用三个反引号包起来123alert('Hello World'); alert('Hello World'); alert('Hello World'); 换行 段落 : 段落之间空一行 换行 : 一行结束时输入两个空格]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
