<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Less入门]]></title>
    <url>%2F2018%2F08%2F12%2Fless%2F</url>
    <content type="text"><![CDATA[前言CSS作为一门标记性语言，虽然简单易懂，但毫无逻辑性可言，遭到一些程序员的不喜。随着技术的兴起，为了使CSS富有逻辑性，涌现出了例如Sass、Less之类的预处理语言。它们让CSS彻底变成一门可以使用变量、循环、继承、自定义方法等多种特性的标记语言，逻辑性得以大大增强。Less诞生于2009年，它扩充了CSS语言，增加了诸如变量、混合、函数等功能，让CSS更易维护、方便制作主题、扩充。它没有去掉任何CSS的功能，而是在现有的语法上，增添了许多额外的功能特性。附上Less的官网：Less 如何使用Less 本地环境在页面中 引入 Less.js 12&lt;link rel=&quot;stylesheet/less&quot; href=&quot;style.less&quot;&gt;&lt;script src=&quot;less.min.js&quot;&gt;&lt;/script&gt; 注意：link 标签一定要在 Less.js 之前引入，并且 link 标签的 rel 属性要设置为stylesheet/less。less.min.js可以去官网下载，也可以使用CDN&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/2.7.2/less.min.js&quot;&gt;&lt;/script&gt; 生产环境在命令行,使用npm安装 12npm install -g less$ lessc styles.less &gt; styles.css 如果使用Webpack，需配合 less-loader 进行处理 变量 值变量 1234567891011121314/* Less */ @color: #999; @bgColor: skyblue;//不要添加引号 @width: 50%; #wrap &#123; color: @color; width: @width; &#125; /* 生成后的 CSS */ #wrap &#123; color: #999; width: 50%; &#125; 以 @ 开头定义变量，并且使用时直接键入 @名称。 在平时工作中，我们就可以把常用的变量封装到一个文件中，这样利于代码组织维护。1234567@lightPrimaryColor: #c5cae9; @textPrimaryColor: #fff; @accentColor: rgb(99, 137, 185); @primaryTextColor: #646464; @secondaryTextColor: #000; @dividerColor: #b6b6b6; @borderColor: #dadada; 变量是常量，只能定义一次，不能重复使用。 选择器变量 12345678910111213141516171819202122232425/* Less */ @mySelector: #wrap; @Wrap: wrap; @&#123;mySelector&#125;&#123; //变量名 必须使用大括号包裹 color: #999; width: 50%; &#125; .@&#123;Wrap&#125;&#123; color:#ccc; &#125; #@&#123;Wrap&#125;&#123; color:#666; &#125; /* 生成的 CSS */ #wrap&#123; color: #999; width: 50%; &#125; .wrap&#123; color:#ccc; &#125; #wrap&#123; color:#666; &#125; 属性变量 1234567891011/* Less */ @borderStyle: border-style; @Soild:solid; #wrap&#123; @&#123;borderStyle&#125;: @Soild;//变量名 必须使用大括号包裹 &#125; /* 生成的 CSS */ #wrap&#123; border-style:solid; &#125; url变量 12345678910/* Less */ @images: &quot;../img&quot;;//需要加引号 body &#123; background: url(&quot;@&#123;images&#125;/dog.png&quot;);//变量名 必须使用大括号包裹 &#125; /* 生成的 CSS */ body &#123; background: url(&quot;../img/dog.png&quot;); &#125; 项目结构改变时，修改其变量即可。 声明变量 12345678910111213141516171819202122232425- 结构: @name: &#123; 属性: 值 ;&#125;;- 使用：@name(); /* Less */ @background: &#123;background:red;&#125;; #main&#123; @background(); &#125; @Rules:&#123; width: 200px; height: 200px; border: solid 1px red; &#125;; #con&#123; @Rules(); &#125; /* 生成的 CSS */ #main&#123; background:red; &#125; #con&#123; width: 200px; height: 200px; border: solid 1px red; &#125; 变量运算 123456789101112131415161718192021- 加减法时 以第一个数据的单位为基准- 乘除法时 注意单位一定要统一 /* Less */ @width:300px; @color:#222; #wrap&#123; width:@width-20; height:@width-20*5; margin:(@width-20)*5; color:@color*2; background-color:@color + #111; &#125; /* 生成的 CSS */ #wrap&#123; width:280px; height:200px; margin:1400px; color:#444; background-color:#333; &#125; 变量作用域 123456789101112/* Less */ @var: @a; @a: 100%; #wrap &#123; width: @var; @a: 9%; &#125; /* 生成的 CSS */ #wrap &#123; width: 9%; &#125; 就近原则 用变量去定义变量12345678910/* Less */ @fnord: &quot;I am fnord.&quot;; @var: &quot;fnord&quot;; #wrap::after&#123; content: @@var; //将@var替换为其值 content:@fnord; &#125; /* 生成的 CSS */ #wrap::after&#123; content: &quot;I am fnord.&quot;; &#125; 嵌套 &amp; 的用法&amp;：代表的上一层选择器的名字，此例便是header 12345678910111213141516/* Less */ #header&#123; &amp;:after&#123; content:&quot;Less is more!&quot;; &#125; &amp;_content&#123;//理解方式：直接把 &amp; 替换成 #header margin:20px; &#125; &#125; /* 生成的 CSS */ #header::after&#123; content:&quot;Less is more!&quot;; &#125; #header_content&#123; margin:20px; &#125; 媒体查询 123456789101112131415161718192021222324/* Less */ #main&#123; //something... @media screen&#123; @media (max-width:768px)&#123; width:100px; &#125; &#125; @media tv &#123; width:2000px; &#125; &#125; /* 生成的 CSS */ @media screen and (maxwidth:768px)&#123; #main&#123; width:100px; &#125; &#125; @media tv&#123; #main&#123; width:2000px; &#125; &#125; 混合方法 无参数方法方法犹如声明的集合，使用时直接键入名称即可。 123456789101112131415161718192021222324252627282930/* Less */ .card() &#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; #wrap&#123; .card(); &#125; /* 生成的 CSS */ #wrap&#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; /* Less */ .card() &#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; #wrap&#123; .card(); &#125; /* 生成的 CSS */ #wrap&#123; background: #f6f6f6; -webkit-box-shadow: 0 1px 2px rgba(151, 151, 151, .58); box-shadow: 0 1px 2px rgba(151, 151, 151, .58); &#125; 默认参数方法Less 可以使用默认参数，如果没有传参数，那么将使用默认参数。@arguments 犹如 JS 中的 arguments 指代的是全部参数。传的参数中必须带着单位。 1234567891011121314151617181920212223#main&#123; .border(0px,5px,30px,red);//必须带着单位 &#125; #wrap&#123; .border(0px); &#125; #content&#123; .border;//等价于 .border() &#125; /* 生成的 CSS */ #main&#123; border:solid 1px red; box-shadow:0px,5px,30px,red; &#125; #wrap&#123; border:solid 1px #000; box-shadow: 0px 50px 30px #000; &#125; #content&#123; border:solid 1px #000; box-shadow: 10px 50px 30px #000; &#125; 方法的匹配模式 123456789101112131415161718192021222324252627/* Less */ .triangle(top,@width:20px,@color:#000)&#123; border-color:transparent transparent @color transparent ; &#125; .triangle(right,@width:20px,@color:#000)&#123; border-color:transparent @color transparent transparent ; &#125; .triangle(bottom,@width:20px,@color:#000)&#123; border-color:@color transparent transparent transparent ; &#125; .triangle(left,@width:20px,@color:#000)&#123; border-color:transparent transparent transparent @color; &#125; .triangle(@_,@width:20px,@color:#000)&#123; border-style: solid; border-width: @width; &#125; #main&#123; .triangle(left, 50px, #999) &#125; /* 生成的 CSS */ #main&#123; border-color:transparent transparent transparent #999; border-style: solid; border-width: 50px; &#125; 第一个参数 left 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。 如果匹配的参数 是变量，则将会匹配，如 @_ 。 方法的命名空间123456789101112131415161718192021222324252627282930313233343536/* Less */ #card()&#123; background: #723232; .d(@w:300px)&#123; width: @w; #a(@h:300px)&#123; height: @h;//可以使用上一层传进来的方法 width: @w; &#125; &#125; &#125; #wrap&#123; #card &gt; .d &gt; #a(100px); // 父元素不能加 括号 &#125; #main&#123; #card .d(); &#125; #con&#123; //不得单独使用命名空间的方法 //.d() 如果前面没有引入命名空间 #card ，将会报错 #card; // 等价于 #card(); .d(20px); //必须先引入 #card &#125; /* 生成的 CSS */ #wrap&#123; height:100px; width:300px; &#125; #main&#123; width:300px; &#125; #con&#123; width:20px; &#125; 在 CSS 中&gt; 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。 在引入命令空间时，如使用 &gt; 选择器，父元素不能加 括号。 不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。 子方法 可以使用上一层传进来的方法 方法的条件筛选Less 没有 if else，可是它有 when1234567891011121314151617181920212223242526272829/* Less */ #card&#123; // and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行 .border(@width,@color,@style) when (@width&gt;100px) and(@color=#999)&#123; border:@style @color @width; &#125; // not 运算符，相当于 非运算 !，条件为 不符合才会执行 .background(@color) when not (@color&gt;=#222)&#123; background:@color; &#125; // , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行 .font(@size:20px) when (@size&gt;50px) , (@size&lt;100px)&#123; font-size: @size; &#125; &#125; #main&#123; #card&gt;.border(200px,#999,solid); #card .background(#111); #card &gt; .font(40px); &#125; /* 生成后的 CSS */ #main&#123; border:solid #999 200px; background:#111; font-size:40px; &#125; 比较运算有： &gt; &gt;= = =&lt; &lt;。 = 代表的是等于 除去关键字 true 以外的值都被视为 false 数量不定的参数如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符 1234567891011121314151617/* Less */ .boxShadow(...)&#123; box-shadow: @arguments; &#125; .textShadow(@a,...)&#123; text-shadow: @arguments; &#125; #main&#123; .boxShadow(1px,4px,30px,red); .textShadow(1px,4px,30px,red); &#125; /* 生成后的 CSS */ #main&#123; box-shadow: 1px 4px 30px red; text-shadow: 1px 4px 30px red; &#125; 循环方法Less 并没有提供 for 循环功能，但这也难不倒 聪明的程序员，使用递归去实现。 12345678910111213141516171819202122/* Less */ .generate-columns(4); .generate-columns(@n, @i: 1) when (@i =&lt; @n) &#123; .column-@&#123;i&#125; &#123; width: (@i * 100% / @n); &#125; .generate-columns(@n, (@i + 1)); &#125; /* 生成后的 CSS */ .column-1 &#123; width: 25%; &#125; .column-2 &#123; width: 50%; &#125; .column-3 &#123; width: 75%; &#125; .column-4 &#123; width: 100%; &#125; 属性拼接方法 +代表的是空格 123456789101112/* Less */ .boxShadow() &#123; box-shadow+: inset 0 0 10px #555; &#125; .main &#123; .boxShadow(); box-shadow+: 0 0 20px black; &#125; /* 生成后的 CSS */ .main &#123; box-shadow: inset 0 0 10px #555, 0 0 20px black; &#125; +_代表的是逗号。 12345678910111213/* Less */ .Animation() &#123; transform+_: scale(2); &#125; .main &#123; .Animation(); transform+_: rotate(15deg); &#125; /* 生成的 CSS */ .main &#123; transform: scale(2) rotate(15deg); &#125; 继承extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。 extend 关键字的使用 123456789101112131415161718192021/* Less */ .animation&#123; transition: all .3s ease-out; .hide&#123; transform:scale(0); &#125; &#125; #main&#123; &amp;:extend(.animation); &#125; #con&#123; &amp;:extend(.animation .hide); &#125; /* 生成后的 CSS */ .animation,#main&#123; transition: all .3s ease-out; &#125; .animation .hide , #con&#123; transform:scale(0); &#125; all 全局搜索替换 123456789101112131415161718/* Less */ #main&#123; width: 200px; &#125; #main &#123; &amp;:after &#123; content:&quot;Less is good!&quot;; &#125; &#125; #wrap:extend(#main all) &#123;&#125; /* 生成的 CSS */ #main,#wrap&#123; width: 200px; &#125; #main:after, #wrap:after &#123; content: &quot;Less is good!&quot;; &#125; 选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre). 可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr);等同于pre:hover:extend(div pre, .bucket tr) 这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。 如果一个规则集包含多个选择器，所有选择器都可以使用extend关键字。 导入 referenceLess 中最强大的特性使用引入的 Less 文件，但不会编译它。1234/* Less */@import (reference) &quot;bootstrap.less&quot;; #wrap:extend(.navbar all)&#123;&#125; 使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用 once12@import (once) &quot;foo.less&quot;;@import (once) &quot;foo.less&quot;; // this statement will be ignored @import语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。 multiple1234567891011121314151617/* Less */ // file: foo.less.a &#123; color: green;&#125;// file: main.less@import (multiple) &quot;foo.less&quot;;@import (multiple) &quot;foo.less&quot;; /* 生成后的 CSS */.a &#123; color: green;&#125;.a &#123; color: green;&#125; 使用@import (multiple)允许导入多个同名文件。 函数 判断类型 isnumber（判断给定的值是否是一个数字） iscolor（判断给定的值是否是一个颜色） isurl（判断给定的值是否是一个 url） 颜色操作 saturate（增加一定数值的颜色饱和度） lighten（增加一定数值的颜色亮度） darken（降低一定数值的颜色亮度） fade（给颜色设定一定数值的透明度） mix（根据比例混合两种颜色） 数学函数 ceil（向上取整） floor（向下取整） percentage（将浮点数转换为百分比字符串） round（四舍五入） sqrt（计算一个数的平方根） abs（计算数字的绝对值，原样保持单位） pow（计算一个数的乘方） Less中使用JS因为 Less 是由 JS 编写，所以 Less 有一得天独厚的特性：代码中使用JS1234567891011121314151617181920212223242526/* Less */ @content:`&quot;aaa&quot;.toUpperCase()`; #randomColor&#123; @randomColor: ~&quot;rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)&quot;; &#125; #wrap&#123; width: ~&quot;`Math.round(Math.random() * 100)`px&quot;; &amp;:after&#123; content:@content; &#125; height: ~&quot;`window.innerHeight`px&quot;; alert:~&quot;`alert(1)`&quot;; #randomColor(); background-color: @randomColor; &#125; /* 生成后的 CSS */ // 弹出 1 #wrap&#123; width: 随机值（0~100）px; height: 743px;//由电脑而异 background: 随机颜色; &#125; #wrap::after&#123; content:&quot;AAA&quot;; &#125; 参考：学习Less-看这篇就够了]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期详解]]></title>
    <url>%2F2018%2F08%2F04%2FnewVue%2F</url>
    <content type="text"><![CDATA[每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等，这个过程就是vue的生命周期。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 Vue的生命周期图示上图是Vue官方文档上的生命周期图示。由图可以看到在vue一整个的生命周期中会有以下八个钩子函数提供给我们在vue生命周期不同的时刻进行操作： beforeCreate（此时date、method和el均没有初始化，可以在此加载loading） created（此时date和method初始化完成，但是DOM节点并没有挂载，判断是否有el节点，如果有则编译template，如果没有则使用vm.$mount创建一个默认节点，此时可以在DOM渲染之前进行数据的初始化和method的自执行等）template参数选项的有无对生命周期的影响。①.如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。②.如果没有template选项，则将外部HTML作为模板编译。③.可以看到template中的模板优先级要高于outer HTML的优先级。 render函数选项 &gt; template选项 &gt; outer HTML. beforeMount（编译模板，并且将此时在el上挂载一个虚拟的DOM节点） mounted（编译模板，且将真实的DOM节点挂载在el上） beforeUpdate（在数据有更新时，进入此钩子函数，虚拟DOM被重新创建） updated（数据更新完成时，进入此钩子函数） beforeDestory（组件销毁前调用，此时将组件上的watchers、子组件和事件都移除掉） destoryed（组件销毁后调用） 一般一个Vue实例初始化时，只会执行前四个钩子函数 Vue实例和子组件之间的生命周期在Vue中，由于父元素的template模板嵌套了子元素，因此在编译模板时，会先进入到父元素的template，然后层层递归进行子元素的模板编译。在创建时，父子组件的生命周期是：父组件beforeCreated -&gt; 父组件created -&gt; 父组件beforeMounted -&gt; 子组件beforeCreated -&gt; 子组件created -&gt; 子组件beforeMounted -&gt; 子组件mounted -&gt; 父组件mounted。在销毁时，父子组件的生命周期是：父组件beforeDestory -&gt; 子组件beforeDestoryed -&gt; 子组件destoryed -&gt; 父组件destoryed 父子组件的生命周期遵循：由外到内，再由内到外]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入域名到页面展示的全过程]]></title>
    <url>%2F2018%2F07%2F29%2FpageShow%2F</url>
    <content type="text"><![CDATA[从浏览器输入域名，到页面展示的过程大致可简单概括为以下几个部分：1.解析输入的域名，获得该域名的IP地址2.向服务器发送请求3.服务器收到、处理、返回请求4.浏览器渲染页面 域名解析DNS查找域名的IP地址会先在缓存中进行查询，其先后顺序为： 1.浏览器缓存 ：在浏览器的缓存中查找是否有该域名对应的IP地址，若有则直接返回IP地址，若无则进行下一步 2.系统缓存 ：系统缓存指本地硬盘上的hosts文件，该文件一般位于系统的C:\Windows\System32\drivers\etc\hosts 3.路由器缓存 : 查找路由器缓存中是否有对应的IP地址 如果在浏览器缓存、系统缓存、路由器缓存中都没有找到ip地址，浏览器便会发起一个DNS请求到本地DNS服务器本地DNS服务器一般是由你的网络接入的服务商提供，如：电信、联通、移动 4.本地DNS服务器 ：DNS请求到达本地DNS服务器后，本地DNS服务器会先在自己的缓存中查找如果找到了就返回找到的IP,这个过程是以递归的方式进行的如果没有，则本地DNS服务器继续向根域名服务器发起请求 5.根域名服务器：本地DNS继续向根域名服务器发出查询请求根域名服务器并没有记录域名与IP之间的对应关系根域名服务器告诉本地DNS服务器，可以到哪个顶级域名服务器上查询 6.顶级域名服务器：本地DNS继续向顶级域名服务器发出查询请求顶级域名服务器接收到请求后，会告诉本地DNS到权限域名服务器上去查询 7.权限域名服务器 ：本地DNS继续向权限域名服务器发出查询请求权限域名服务器查询到域名对应的IP后，将IP地址返回给本地DNS 本地DNS接收后将其保存到自己的缓存中，以备下次查询，提高查询速度至此，一个IP地址的查询就此结束； 整个DNS域名解析是一个递归查询的过程本地域名服务器向根域名服务器、顶级域名服务器和主机域名服务器发起的查询请求是一个迭代查询的过程 发送请求浏览器拿到域名对应的IP地址之后，会向服务器发起TCP连接请求连接请求到达服务器端后，通过三次握手建立TCP连接建立TCP连接后，浏览器向服务器发送http请求 浏览器发送请求的端口为1024~65535的一个随机端口向服务器的请求端口为：HTTP协议使用80端口/8080端口，HTTPS使用443端口 响应请求服务器收到客户端请求后，对请求进行处理，包括访问数据库、获取需要获取的内容等然后服务器向浏览器返回一个HTTP响应，将请求的数据发送给浏览器浏览器收到请求后通过四次挥手释放TCP连接 渲染页面页面渲染主要分为以下几步： 1.浏览器把获取到的HTML代码解析成1个DOM树 HTML中的每个tag都是DOM树中的1个节点，根节点就是我们常用的document对象DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等 2.浏览器把CSS解析成CSSOM(样式结构体)，在解析的过程中会去掉浏览器不能识别的样式 3.DOM Tree 和CSSOM组合后构建render tree render tree类似于DOM tree，但区别很大，render tree能识别样式，render tree中每个node都有自己的stylerender tree不包含隐藏的节点 (这些节点不会用于呈现，而且不会影响呈现的,比如display:none的节点)visibility:hidden隐藏的元素还是会包含到 render tree中的(visibility:hidden 会影响布局(layout)，会占有空间) 4.浏览器根据render tree渲染和展示页面 浏览器在构造页面时，当浏览器从服务器端接收到HTML文档时，会从上到下依次解析HTML文档，转换为DOM树在转换过程中，如果发现某个Node（节点）引用了CSS、IMG，则会发起一个request去请求CSS或IMG,而浏览器则会继续执行下面的HTML转换，而不等待request的返回,当request返回后，只需要把相应的内容放到对应的Node上即可但是当引用了JS的时候，浏览器发起一个JS的request请求后，会一直等待该请求的返回,因为浏览器需要构建一个稳定的DOM树，而JS代码很有可能会改变DOM结构,浏览器为了防止出现这种情况，所以会阻塞后续资源的下载 回流与重绘回流：当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建 每个页面至少需要一次回流，就是在页面第一次加载的时候 重绘:当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局 回流必将引起重绘，而重绘不一定会引起回流在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树,完成回流后，浏览器会重新绘制受影响的部分到屏幕中回流可以理解为render树的结构发生了变化，需要重新构建重绘指结构没有变化，只是一些对结构布局没有产生影响的元素发生了变化]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2018%2F07%2F21%2FMarkdown%2F</url>
    <content type="text"><![CDATA[前言在使用Hexo搭建博客系统后，通过hexo new XXX创建一个新的博客文章，编写博客内容所使用的模板为.md文件对此，有必要了解一下关于Markdown的基本语法，以提高写作效率。 Markdown介绍Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。优点： 纯文本格式，故可以用任何编辑器打开并编辑 语法简介易懂，具有很好的可读性 转化格式方便，可以轻松转化为Html、PPT、Word等格式文件 基本语法介绍标题在 Markdown 中，只需在文本前面加上#即可表示标题，标题总共六级同理，二级标题、三级标题、四级标题、五级标题和六级标题都只需要添加相应数量的#即可，标题字号便会相应降低。例如：123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 注：#和标题之间建议保留一个字符的空格。 字体 加粗 :将要加粗的文字用两个*号包起来 **Bold** —– Bold 斜体 :将要倾斜的文字用一个*号包起来 斜体加粗 :将要倾斜加粗的文字用三个*号包起来 删除线 : 将要加删除线的文字用两个~~号包起来 引用 引用 :在引用的文字前加&gt;即可例如： &gt; 引用内容 引用内容 分割线 分割线 (HR) :三个或者三个以上的-或者*例如 : --- *** 链接 链接 :[超链接名](超链接地址)例如 :[百度](https://www.baidu.com/)显示为 :百度 图片12345![alt](address &quot;title&quot;)alt是指显示在图片下面的文字 address是指图片的地址title是指当鼠标移到图片上时显示的内容，title可有可无 例如 :![头像](source/uploads/touxiang.jpg) 列表无序列表语法：无序列表用- + *任何一种都可以例如 :12- 有序列表- 无序列表 显示为 : 有序列表 无序列表有序列表语法：数字加点例如 : 121.有序列表 2.无序列表 显示为：1.有序列表2.无序列表 列表嵌套在下一级的-符号前敲四个空格例如 :1234- 一级列表 - 二级列表 - 二级列表 - 二级列表 显示为： 一级列表 二级列表 二级列表 二级列表 表格语法为 :1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 第二行分割表头和内容文字默认居左--- 表示文字居左：--：表示文字居中----：表示文字居右显示为： 表头 表头 表头 内容 内容 内容 内容 内容 内容 内嵌代码单行代码：将代码用一个反引号包起来alert(&#39;Hello World&#39;); 多行代码：将代码用三个反引号包起来123alert(&apos;Hello World&apos;); alert(&apos;Hello World&apos;); alert(&apos;Hello World&apos;); 换行 段落 : 段落之间空一行 换行 : 一行结束时输入两个空格]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
